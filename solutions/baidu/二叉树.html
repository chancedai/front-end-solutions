<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>title</title>
</head>
<body>
	<h1>二叉树</h1>
		<a href="http://www.cnblogs.com/ghostgift/archive/2013/03/04/2941723.html" target="_blank">http://www.cnblogs.com/ghostgift/archive/2013/03/04/2941723.html</a>
		<script type="text/javascript">
			(function(){
				/*
				 *二叉树的节点对象
				 */
				function Node() {
				    this.text = '';           //节点的文本
				    this.leftChild = null;    //节点的左孩子引用
				    this.rightChild = null;   //节点右孩子引用
				}


				var charecters = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'];

				function buildTree(node, i) {
						var leftIndex = 2 * i + 1, //左孩子节点的索引
							rightIndex = 2 * i + 2; //右孩子节点的索引
						if (leftIndex < charecters.length) { //判断索引的长度是否超过了charecters数组的大小
							var childNode = new Node(); //创建一个新的节点对象
							childNode.text = charecters[leftIndex]; //给节点赋值
							node.leftChild = childNode; //给当前节点node加入左孩子节点
							buildTree(childNode, leftIndex); //递归创建左孩子
						}
						if (rightIndex < charecters.length) { //下面注释参照上面的构建左孩子的节点
							var childNode = new Node();
							childNode.text = charecters[rightIndex];
							node.rightChild = childNode;
							buildTree(childNode, rightIndex);
						}
					}
					//下面构造二叉树
				var node = new Node();
				node.text = charecters[0];
				buildTree(node, 0); //索引i是从0开始构建

				console.log(node);

				// 栈 先进先出
				function Stack() {
	                var stack = new Array();               //存放栈的数组
	                //压栈
	                this.push = function(o) {
	                    stack.push(o);
	                };
	                //出栈
	                this.pop = function() {
	                    var o = stack[stack.length-1];
	                    stack.splice(stack.length-1, 1);
	                    return o;
	                };
	                //检查栈是否为空
	                this.isEmpty = function() {
	                    if(stack.length <= 0) {
	                        return true;
	                    }
	                    else {
	                        return false;
	                    }
	                };
	            }

	            function firstIteration(node) {
                    if(node.leftChild) {                   //判断当前节点是否有左孩子
                        firstIteration(node.leftChild);    //递归左孩子
                    }
                    if(node.rightChild) {                  //判断当前节点是否有右孩子
                        firstIteration(node.rightChild);   //递归右孩子
                    }
                    console.log(node.text);
                }
                //递归遍历二叉树
                console.log('先序遍历的递归方式');
                firstIteration(node);

			})();
		</script>
</body>
</html>